# МЕТОДЫ CЕЛЕКТОРОВ В SELENIUM

find_element(By.ID, value) — поиск по уникальному атрибуту id элемента. 
find_element(By.CSS_SELECTOR, value) — поиск элемента с помощью правил на основе CSS
find_element(By.XPATH, value) — поиск с помощью языка запросов XPath
find_element(By.NAME, value) — поиск по атрибуту name элемента
find_element(By.TAG_NAME, value) — поиск элемента по названию тега элемента
find_element(By.CLASS_NAME, value) — поиск по значению атрибута class
find_element(By.LINK_TEXT, value) — поиск ссылки на странице по полному совпадению
find_element(By.PARTIAL_LINK_TEXT, value) — поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки

option1 = browser.find_element(By.CSS_SELECTOR, "[value='python']") -- name тоже ок
option1 = browser.find_element(By.CSS_SELECTOR, "[for='java']")
option1.click()


# CЕЛЕКТОРЫ

## Примеры
http://suninjuly.github.io/cats.html
https://suninjuly.github.io/blog_example.html

## По id
#bullet 
Если ваши разработчики проставляют всем элементам в приложении уникальный id,
то вам повезло, лучше использовать этот метод, так как он наиболее стабильный

## По тегу
h1

## По CSS-селектору ()
Это универсальный метод поиска, так как большинство веб-приложений использует CSS
для вёрстки и задания оформления страницам. 
Если find_element_by_id вам не подходит из-за отсутствия id у элементов,
то скорее всего вы будете использовать именно этот метод в ваших тестах

## По значению атрибута
[id="bullet"]
[value="Cat memes"]
[value='python']
p[data-type="description"] -- тег + по значению

## По name
name="bullet-cat"

## По class
class="jumbotron-heading"
.jumbotron-heading
p.blue - тег + класс
class="lead text-muted" -- порядок классов при этом важен, чувствителен к регистру!
lead.text-muted -- gорядок классов не важен, более гибкий, чувствителен к регистру!

## По потомку
#post2 .title -- элемент-потомок от #post с классом title
#post2.title -- без пробела = одновременно содержит #post2 и класс title

## По дочернему элементу
#post2 > div.title -- дочерний элемент  от #post - div с классом title

## По порядковому номеру дочернего элемента
#posts > .item:nth-child(2) > .title
:nth-child(2) — псевдо-класс позволяет найти второй по порядку элемент среди дочерних от #posts

## По нескольким классам
.title.second -- сразу несколько классов элемента применены

## xPath
Символ / аналогичен символу > в CSS-селекторе, а символ // -- пробелу.
el1/el2 -- выбирает элементы el2, являющиеся прямыми потомками el1;
el1//el2 -- выбирает элементы el2, являющиеся потомками el1 любой степени вложенности.

/html/body/header == //header
//img[@id='bullet'] по атрибуту -- будь то id, class, title (или любой другой)
//div[@class="row"]/div[2] -- по порядковому номеру потомка
//p[text()="Lenin cat"] -- по полному совпадению текста
//p[contains(text(), "cat")] -- все абзацы текста, со словом cat
//div[contains(@class, "navbar")] -- по частичному совпадению текста или атрибута
можно искать по частичному совпадению других атрибутов, это удобно, если у элемента несколько классов
//img[@name='bullet-cat' and @data-type='animal'] - булевы операции (and, or, not)
//div/*[@class="jumbotron-heading"] -- * = команда выбора всех элементов

## Что важно знать про XPath, чтобы пользоваться им безболезненно:

1. Поиск регистрозависим 
2. XPath — это единственный способ найти элемент по внутреннему тексту. 
3. Не всегда поиск по тексту — это хорошая практика, особенно в случае мультиязычных сайтов. 
4. Не используйте селекторы вида //div[1]/div[2]/div[3] без крайней нужды:
   (по такому селектору невозможно с первого раза понять, что за элемент вы ищете.
А когда структура страницы хоть немного изменится, селектор может перестать работать) 
5. Если есть возможность использовать CSS-селекторы: сlass, id или name — лучше использовать их вместо поиска по XPath; 
6. Можно искать по полному или частичному совпадению текста или любого атрибута; 
7. Можно использовать булевы операции и простую арифметику; 
8. Можно удобно перемещаться по структуре документа (переходить к потомкам и к родителям); 
9. Подойдет, когда у сайта всё плохо с атрибутами и нет возможности достучаться до разработчиков; 
10. Есть мнение, что поиск по XPath в среднем медленнее, чем по css. Но достоверно это неизвестно; 
11. Не стоит использовать разные расширения для браузеров по поиску XPath: они подбирают нечитабельные и переусложненные селекторы. Лучше потратить немного времени и разобраться в синтаксисе самостоятельно, тем более, что он не очень сложный.


